# Guia de Design - Sistema de Chat com IA (Refinado v2)

## üö® PRIORIDADE M√ÅXIMA: Sincroniza√ß√£o Streaming/Banco de Dados

### Arquitetura de Estado √önico (Single Source of Truth)

#### Princ√≠pios Fundamentais
1. **Banco de dados √© a √∫nica fonte de verdade** - Nenhuma duplica√ß√£o de estado
2. **Streaming √© tempor√°rio** - Apenas visualiza√ß√£o em tempo real, sem persist√™ncia local
3. **Transi√ß√£o sem re-renderiza√ß√£o** - De streaming para persistido sem flicker
4. **WebSocket como canal √∫nico** - Toda comunica√ß√£o por um canal s√≥

### Implementa√ß√£o Cr√≠tica

#### Hook Principal - Gerenciamento de Estado

```typescript
// useChatWithPersistence.ts
interface ChatState {
  messages: ChatMessage[];
  streamingMessageId: string | null;
  streamingContent: string;
  toolStatuses: Map<string, ToolStatus>;
}

interface ToolStatus {
  toolCallId: string;
  status: 'pending' | 'executing' | 'success' | 'error';
  toolMessageId?: string;
}

export const useChatWithPersistence = () => {
  const [state, setState] = useState<ChatState>({
    messages: [],
    streamingMessageId: null,
    streamingContent: '',
    toolStatuses: new Map()
  });

  // Refer√™ncia para evitar atualiza√ß√µes duplicadas
  const processedMessageIds = useRef(new Set<string>());
  const wsRef = useRef<WebSocket | null>(null);

  // Handler unificado para eventos WebSocket
  const handleWebSocketMessage = useCallback((event: MessageEvent) => {
    const data = JSON.parse(event.data);

    switch (data.type) {
      case 'token':
        // Apenas acumular streaming, n√£o criar mensagem
        setState(prev => ({
          ...prev,
          streamingContent: prev.streamingContent + data.content,
          streamingMessageId: data.messageId
        }));
        break;

      case 'message_saved':
        // Mensagem persistida no banco - substituir streaming
        if (!processedMessageIds.current.has(data.message.id)) {
          processedMessageIds.current.add(data.message.id);
          
          setState(prev => {
            // Remover streaming se for da mesma mensagem
            const isStreamingMessage = prev.streamingMessageId === data.message.id;
            
            return {
              ...prev,
              messages: [...prev.messages, data.message],
              streamingContent: isStreamingMessage ? '' : prev.streamingContent,
              streamingMessageId: isStreamingMessage ? null : prev.streamingMessageId
            };
          });
        }
        break;

      case 'tool_call':
        // Tool foi chamada - adicionar ao tracking
        setState(prev => {
          const newToolStatuses = new Map(prev.toolStatuses);
          newToolStatuses.set(data.toolCallId, {
            toolCallId: data.toolCallId,
            status: 'executing'
          });
          return { ...prev, toolStatuses: newToolStatuses };
        });
        break;

      case 'tool_result':
        // Tool retornou resultado
        setState(prev => {
          const newToolStatuses = new Map(prev.toolStatuses);
          const status = newToolStatuses.get(data.toolCallId);
          if (status) {
            status.status = data.success ? 'success' : 'error';
            status.toolMessageId = data.messageId;
          }
          return { ...prev, toolStatuses: newToolStatuses };
        });
        break;
    }
  }, []);

  // Fun√ß√£o para obter mensagens renderiz√°veis
  const getRenderableMessages = useCallback(() => {
    const renderableMessages = [...state.messages];
    
    // Adicionar mensagem de streaming se existir
    if (state.streamingMessageId && state.streamingContent) {
      renderableMessages.push({
        id: state.streamingMessageId,
        role: 'assistant',
        content: state.streamingContent,
        isStreaming: true,
        metadata: {}
      });
    }
    
    return renderableMessages;
  }, [state]);

  // Fun√ß√£o para obter status de uma tool
  const getToolStatus = useCallback((toolCallId: string): ToolStatus | undefined => {
    return state.toolStatuses.get(toolCallId);
  }, [state.toolStatuses]);

  return {
    messages: getRenderableMessages(),
    sendMessage: (content: string) => {
      wsRef.current?.send(JSON.stringify({ type: 'chat', content }));
    },
    getToolStatus,
    isConnected: wsRef.current?.readyState === WebSocket.OPEN
  };
};
```

### Preven√ß√£o de Duplica√ß√£o - Regras Cr√≠ticas

```typescript
// Componente de Mensagem - NUNCA re-renderizar desnecessariamente
const ChatMessage = React.memo(({ message }: { message: ChatMessage }) => {
  // Se √© tool, n√£o renderizar
  if (message.role === 'tool') return null;

  return (
    <div className={cn(
      "message",
      message.role === 'user' ? 'user-message' : 'assistant-message'
    )}>
      <MessageContent message={message} />
      {message.metadata?.toolCalls && (
        <ToolCallsDisplay toolCalls={message.metadata.toolCalls} />
      )}
    </div>
  );
}, (prevProps, nextProps) => {
  // Compara√ß√£o customizada - evitar re-renders
  return prevProps.message.id === nextProps.message.id &&
         prevProps.message.content === nextProps.message.content &&
         !prevProps.message.isStreaming === !nextProps.message.isStreaming;
});
```

## Sistema Simplificado de Tool Calls

### Visual Minimalista - Apenas Nome + √çcone

```tsx
// ToolCallIndicator.tsx
interface ToolCallIndicatorProps {
  toolCall: {
    id: string;
    name: string;
  };
}

const ToolCallIndicator: React.FC<ToolCallIndicatorProps> = ({ toolCall }) => {
  const { getToolStatus } = useChatWithPersistence();
  const status = getToolStatus(toolCall.id);

  const getIcon = () => {
    if (!status || status.status === 'executing') {
      return <Loader2 className="w-4 h-4 animate-spin" />;
    }
    
    if (status.status === 'success') {
      // √çcones espec√≠ficos por tool
      switch (toolCall.name) {
        case 'getWorkflow':
          return <Search className="w-4 h-4" />;
        case 'createNode':
          return <Plus className="w-4 h-4" />;
        case 'executeWorkflow':
          return <Play className="w-4 h-4" />;
        default:
          return <Check className="w-4 h-4" />;
      }
    }
    
    return <X className="w-4 h-4 text-red-500" />;
  };

  return (
    <span className="inline-flex items-center gap-1.5 px-2 py-0.5 rounded-full bg-muted text-sm">
      {getIcon()}
      <span className="text-muted-foreground">{toolCall.name}</span>
    </span>
  );
};
```

### CSS Essencial para Tools

```css
/* Tool indicator - super simples */
.tool-indicator {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: 2px 8px;
  background: hsl(var(--muted));
  border-radius: 9999px;
  font-size: 0.875rem;
}

/* Spinner */
@keyframes spin {
  to { transform: rotate(360deg); }
}

.animate-spin {
  animation: spin 1s linear infinite;
}
```

## Fluxo de Dados Simplificado

### 1. Mensagem do Assistant com Tool Call

```typescript
// Backend envia
{
  type: 'message_saved',
  message: {
    id: 'msg_123',
    role: 'assistant',
    content: 'Vou buscar os dados do workflow...',
    metadata: {
      toolCalls: [{
        id: 'call_abc',
        name: 'getWorkflow'
      }]
    }
  }
}
```

### 2. Tool em Execu√ß√£o

```typescript
// Backend envia status
{
  type: 'tool_call',
  toolCallId: 'call_abc',
  status: 'executing'
}
```

### 3. Tool Conclu√≠da

```typescript
// Backend envia resultado (mas n√£o mostramos o content)
{
  type: 'tool_result',
  toolCallId: 'call_abc',
  success: true,
  messageId: 'msg_124' // Refer√™ncia √† mensagem tool no banco
}
```

## Componente Principal do Chat

```tsx
// WorkflowChat.tsx
export const WorkflowChat: React.FC<{ workflowId: string }> = ({ workflowId }) => {
  const { messages, sendMessage, isConnected } = useChatWithPersistence();
  const messagesEndRef = useRef<HTMLDivElement>(null);

  // Auto-scroll APENAS quando necess√°rio
  useEffect(() => {
    const lastMessage = messages[messages.length - 1];
    if (lastMessage?.isStreaming || lastMessage?.role === 'user') {
      messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
    }
  }, [messages]);

  return (
    <div className="flex flex-col h-full">
      {/* √Årea de mensagens */}
      <div className="flex-1 overflow-y-auto p-4 space-y-4">
        {messages.length === 0 ? (
          <WelcomeScreen />
        ) : (
          messages.map(message => (
            <ChatMessage key={message.id} message={message} />
          ))
        )}
        <div ref={messagesEndRef} />
      </div>

      {/* Input */}
      <ChatInput
        onSend={sendMessage}
        disabled={!isConnected}
      />
    </div>
  );
};
```

## Checklist de Implementa√ß√£o Cr√≠tica

### Fase 1: Funda√ß√£o (FAZER PRIMEIRO)
- [ ] Implementar `useChatWithPersistence` com deduplica√ß√£o
- [ ] Configurar WebSocket com handlers √∫nicos
- [ ] Implementar `processedMessageIds` para evitar duplicatas
- [ ] Testar transi√ß√£o streaming ‚Üí persistido sem re-render

### Fase 2: Tool Calls Simples
- [ ] Criar `ToolCallIndicator` minimalista
- [ ] Implementar Map de `toolStatuses`
- [ ] Vincular por `toolCallId`
- [ ] Testar m√∫ltiplas tools simult√¢neas

### Fase 3: Polish Visual (DEPOIS)
- [ ] Remover avatares e √≠cones
- [ ] Aplicar backgrounds corretos
- [ ] Implementar cores cinzas nos hovers
- [ ] Limpar CSS desnecess√°rio

## Testes Cr√≠ticos

```typescript
// tests/chat-sync.test.ts
describe('Chat Synchronization', () => {
  it('should not duplicate messages when transitioning from streaming to saved', async () => {
    // Simular streaming
    ws.send({ type: 'token', content: 'Hello', messageId: 'msg_1' });
    ws.send({ type: 'token', content: ' world', messageId: 'msg_1' });
    
    // Simular salvamento
    ws.send({ 
      type: 'message_saved', 
      message: { id: 'msg_1', content: 'Hello world', role: 'assistant' }
    });
    
    // Verificar que h√° apenas 1 mensagem
    expect(getMessages()).toHaveLength(1);
    expect(getMessages()[0].content).toBe('Hello world');
    expect(getMessages()[0].isStreaming).toBe(false);
  });

  it('should track tool execution status correctly', async () => {
    // Tool call
    ws.send({ type: 'tool_call', toolCallId: 'call_1', status: 'executing' });
    expect(getToolStatus('call_1')).toBe('executing');
    
    // Tool result
    ws.send({ type: 'tool_result', toolCallId: 'call_1', success: true });
    expect(getToolStatus('call_1')).toBe('success');
  });
});
```

## Estrutura de Dados Final

```typescript
// types/chat.ts
export interface ChatMessage {
  id: string;
  role: 'user' | 'assistant' | 'tool';
  content: string;
  metadata?: {
    toolCalls?: Array<{
      id: string;
      name: string;
    }>;
    toolCallId?: string; // Para mensagens tool
    status?: 'success' | 'error';
  };
  isStreaming?: boolean; // Apenas para renderiza√ß√£o tempor√°ria
  created_at: string;
}
```

## Notas Importantes

1. **NUNCA** salvar estado de streaming no localStorage ou state persistente
2. **SEMPRE** usar o banco como fonte √∫nica de verdade
3. **Tool messages** existem no banco mas N√ÉO s√£o renderizadas
4. **Streaming** √© apenas visual tempor√°rio
5. **WebSocket** √© o √∫nico canal de comunica√ß√£o

---

Este documento prioriza a **funcionalidade correta** sobre apar√™ncia. A sincroniza√ß√£o perfeita entre streaming e banco de dados √© o requisito mais cr√≠tico. Aspectos visuais s√£o secund√°rios e devem ser implementados apenas ap√≥s a funcionalidade estar 100% est√°vel.